/*--------------------------------------------------*/
/*--------------------Legend------------------------*/
/* '<Type>'          = Token type                   */
/* '<Type:Value>'    = Token                        */
/* 'someRule := ...' = Grammar rule creation        */
/* 'someRule'        = Grammar rule calling         */
/* '...*'            = Zero or more times           */
/* '...+'            = One or more times            */
/* '...?'            = Zero or one times            */
/* '(...)'           = Grouping                     */
/* '...|...'         = Either one. Can be chained   */
/*--------------------------------------------------*/
/* Begin from the top, jump to other rules when     */
/* They get called.                                 */
/*--------------------------------------------------*/

statement_list      := (<NEW_LINE>)* (statement (<NEW_LINE>)+)*

statement           := <KEYWORD:var> <IDENTIFIER> <ASSIGN> expression
                    := <KEYWORD:var> <IDENTIFIER> expression
                    := <IDENTIFIER> <ASSIGN> expression
                    := <KEYWORD:if> expression <KEYWORD:then> statement_list
                            (<KEYWORD:elif> expression <KEYWORD:then> statement_list)*
                            (<KEYWORD:else> statement_list)?
                            <KEYWORD:end>

                    := expression

func_def            := <KEYWORD:func> <IDENTIFIER> <LPAREN> (<IDENTIFIER> (<COMMA> <IDENTIFIER>)*)? <RPAREN> 
                            <KEYWORD:then> statement_list <KEYWORD:end>

expression          := logic_or

// This section shows expression precedence. Lower rules have higher precedence

logic_or            := logic_and (<LOGIC_OR> logic_and)*

logic_and           := logic_not (<LOGIC_AND> logic_not)*

logic_not           := <LOGIC_NOT> logic_not
                    := comparison

comparison          := add_expr (<LESS_THAN | GREATER_THAN | LESS_EQUAL | GREATER_EQUAL | EQUAL | NOT_EQUAL> add_expr)*

add_expr            := mul_expr (<ADD|SUB> mul_expr)*

mul_expr            := sign (<MUL|DIV> sign)*

sign                := <ADD|SUB> sign
                    := power

power               := call (<Power> sign)*

call                := factor (<LPAREN> (expression (<COMMA> expression)*)? <RPAREN>)?

factor              := <INT_LITERAL|FLOAT_LITERAL|BOOL_LITERAL|IDENTIFIER>
                    := <LPAREN> expression <RPAREN>
                